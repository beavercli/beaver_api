// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLanguages = `-- name: CountLanguages :one
SELECT COUNT(*) FROM languages
`

func (q *Queries) CountLanguages(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLanguages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTags = `-- name: CountTags :one
SELECT COUNT(*) FROM tags
`

func (q *Queries) CountTags(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTags)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteContributorsExcept = `-- name: DeleteContributorsExcept :exec
DELETE FROM contributors WHERE NOT (id = ANY($1::BIGINT[]))
`

func (q *Queries) DeleteContributorsExcept(ctx context.Context, ids []int64) error {
	_, err := q.db.Exec(ctx, deleteContributorsExcept, ids)
	return err
}

const deleteLanguagesExcept = `-- name: DeleteLanguagesExcept :exec
DELETE FROM languages WHERE NOT (id = ANY($1::BIGINT[]))
`

func (q *Queries) DeleteLanguagesExcept(ctx context.Context, ids []int64) error {
	_, err := q.db.Exec(ctx, deleteLanguagesExcept, ids)
	return err
}

const deleteSnippetsBefore = `-- name: DeleteSnippetsBefore :exec
DELETE FROM snippets WHERE created_at < $1
`

func (q *Queries) DeleteSnippetsBefore(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteSnippetsBefore, createdAt)
	return err
}

const deleteTagsExcept = `-- name: DeleteTagsExcept :exec
DELETE FROM tags WHERE NOT (id = ANY($1::BIGINT[]))
`

func (q *Queries) DeleteTagsExcept(ctx context.Context, ids []int64) error {
	_, err := q.db.Exec(ctx, deleteTagsExcept, ids)
	return err
}

const getContributorIDByEmail = `-- name: GetContributorIDByEmail :one
SELECT id FROM contributors WHERE email=$1
`

func (q *Queries) GetContributorIDByEmail(ctx context.Context, email pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getContributorIDByEmail, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getContributorsBySnippetID = `-- name: GetContributorsBySnippetID :many
SELECT c.id, c.first_name, c.last_name, c.email
FROM contributors c
INNER JOIN snippet_contributors sc ON c.id = sc.contributor_id
WHERE sc.snippet_id = $1
`

type GetContributorsBySnippetIDRow struct {
	ID        int64
	FirstName pgtype.Text
	LastName  pgtype.Text
	Email     pgtype.Text
}

func (q *Queries) GetContributorsBySnippetID(ctx context.Context, snippetID int64) ([]GetContributorsBySnippetIDRow, error) {
	rows, err := q.db.Query(ctx, getContributorsBySnippetID, snippetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContributorsBySnippetIDRow
	for rows.Next() {
		var i GetContributorsBySnippetIDRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLanguageIDByName = `-- name: GetLanguageIDByName :one
SELECT id FROM languages WHERE name=$1
`

func (q *Queries) GetLanguageIDByName(ctx context.Context, name pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getLanguageIDByName, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getSnippetByID = `-- name: GetSnippetByID :one
SELECT
    s.id,
    s.title,
    s.code,
    s.project_url,
    s.created_at,
    s.updated_at,
    l.id AS language_id,
    l.name AS language_name
FROM snippets s
LEFT JOIN languages l ON s.language_id = l.id
WHERE s.id = $1
`

type GetSnippetByIDRow struct {
	ID           int64
	Title        pgtype.Text
	Code         pgtype.Text
	ProjectUrl   pgtype.Text
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	LanguageID   pgtype.Int8
	LanguageName pgtype.Text
}

func (q *Queries) GetSnippetByID(ctx context.Context, id int64) (GetSnippetByIDRow, error) {
	row := q.db.QueryRow(ctx, getSnippetByID, id)
	var i GetSnippetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Code,
		&i.ProjectUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LanguageID,
		&i.LanguageName,
	)
	return i, err
}

const getSnippetIDByTitle = `-- name: GetSnippetIDByTitle :one
SELECT id FROM snippets WHERE title=$1
`

func (q *Queries) GetSnippetIDByTitle(ctx context.Context, title pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getSnippetIDByTitle, title)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTagIDByName = `-- name: GetTagIDByName :one
SELECT id FROM tags WHERE name=$1
`

func (q *Queries) GetTagIDByName(ctx context.Context, name pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getTagIDByName, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTagsBySnippetID = `-- name: GetTagsBySnippetID :many
SELECT t.id, t.name
FROM tags t
INNER JOIN snippet_tags st ON t.id = st.tag_id
WHERE st.snippet_id = $1
`

type GetTagsBySnippetIDRow struct {
	ID   int64
	Name pgtype.Text
}

func (q *Queries) GetTagsBySnippetID(ctx context.Context, snippetID int64) ([]GetTagsBySnippetIDRow, error) {
	rows, err := q.db.Query(ctx, getTagsBySnippetID, snippetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsBySnippetIDRow
	for rows.Next() {
		var i GetTagsBySnippetIDRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkSnippetContributor = `-- name: LinkSnippetContributor :exec
INSERT INTO snippet_contributors (snippet_id, contributor_id) VALUES($1, $2) ON CONFLICT (snippet_id, contributor_id) DO NOTHING
`

type LinkSnippetContributorParams struct {
	SnippetID     int64
	ContributorID int64
}

func (q *Queries) LinkSnippetContributor(ctx context.Context, arg LinkSnippetContributorParams) error {
	_, err := q.db.Exec(ctx, linkSnippetContributor, arg.SnippetID, arg.ContributorID)
	return err
}

const linkSnippetTag = `-- name: LinkSnippetTag :exec
INSERT INTO snippet_tags (snippet_id, tag_id) VALUES($1, $2) ON CONFLICT (snippet_id, tag_id) DO NOTHING
`

type LinkSnippetTagParams struct {
	SnippetID int64
	TagID     int64
}

func (q *Queries) LinkSnippetTag(ctx context.Context, arg LinkSnippetTagParams) error {
	_, err := q.db.Exec(ctx, linkSnippetTag, arg.SnippetID, arg.TagID)
	return err
}

const listContributors = `-- name: ListContributors :many

SELECT id, created_at, updated_at, first_name, last_name, email FROM contributors OFFSET $1 LIMIT $2
`

type ListContributorsParams struct {
	Offset int32
	Limit  int32
}

// Contributors
func (q *Queries) ListContributors(ctx context.Context, arg ListContributorsParams) ([]Contributor, error) {
	rows, err := q.db.Query(ctx, listContributors, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contributor
	for rows.Next() {
		var i Contributor
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLanguages = `-- name: ListLanguages :many

SELECT id, created_at, updated_at, name FROM languages OFFSET $1 LIMIT $2
`

type ListLanguagesParams struct {
	Offset int32
	Limit  int32
}

// Languages
func (q *Queries) ListLanguages(ctx context.Context, arg ListLanguagesParams) ([]Language, error) {
	rows, err := q.db.Query(ctx, listLanguages, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkedContributorIDs = `-- name: ListLinkedContributorIDs :many
SELECT DISTINCT(contributor_id) FROM snippet_contributors
`

func (q *Queries) ListLinkedContributorIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, listLinkedContributorIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var contributor_id int64
		if err := rows.Scan(&contributor_id); err != nil {
			return nil, err
		}
		items = append(items, contributor_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkedTagIDs = `-- name: ListLinkedTagIDs :many
SELECT DISTINCT(tag_id) FROM snippet_tags
`

func (q *Queries) ListLinkedTagIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, listLinkedTagIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var tag_id int64
		if err := rows.Scan(&tag_id); err != nil {
			return nil, err
		}
		items = append(items, tag_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many

SELECT id, created_at, updated_at, name FROM tags OFFSET $1 LIMIT $2
`

type ListTagsParams struct {
	Offset int32
	Limit  int32
}

// Tags
func (q *Queries) ListTags(ctx context.Context, arg ListTagsParams) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listTags, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsedLanguageIDs = `-- name: ListUsedLanguageIDs :many
SELECT DISTINCT(language_id) FROM snippets
`

func (q *Queries) ListUsedLanguageIDs(ctx context.Context) ([]pgtype.Int8, error) {
	rows, err := q.db.Query(ctx, listUsedLanguageIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Int8
	for rows.Next() {
		var language_id pgtype.Int8
		if err := rows.Scan(&language_id); err != nil {
			return nil, err
		}
		items = append(items, language_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertContributor = `-- name: UpsertContributor :exec
INSERT INTO contributors (first_name, last_name, email) VALUES($1, $2, $3) ON CONFLICT (email) DO NOTHING
`

type UpsertContributorParams struct {
	FirstName pgtype.Text
	LastName  pgtype.Text
	Email     pgtype.Text
}

func (q *Queries) UpsertContributor(ctx context.Context, arg UpsertContributorParams) error {
	_, err := q.db.Exec(ctx, upsertContributor, arg.FirstName, arg.LastName, arg.Email)
	return err
}

const upsertLanguage = `-- name: UpsertLanguage :exec
INSERT INTO languages (name) VALUES($1) ON CONFLICT (name) DO NOTHING
`

func (q *Queries) UpsertLanguage(ctx context.Context, name pgtype.Text) error {
	_, err := q.db.Exec(ctx, upsertLanguage, name)
	return err
}

const upsertSnippet = `-- name: UpsertSnippet :exec

INSERT INTO snippets (title, code, project_url, language_id, created_at) VALUES($1, $2, $3, $4, $5)
ON CONFLICT (title) DO UPDATE SET created_at = EXCLUDED.created_at
`

type UpsertSnippetParams struct {
	Title      pgtype.Text
	Code       pgtype.Text
	ProjectUrl pgtype.Text
	LanguageID pgtype.Int8
	CreatedAt  pgtype.Timestamptz
}

// Snippets
func (q *Queries) UpsertSnippet(ctx context.Context, arg UpsertSnippetParams) error {
	_, err := q.db.Exec(ctx, upsertSnippet,
		arg.Title,
		arg.Code,
		arg.ProjectUrl,
		arg.LanguageID,
		arg.CreatedAt,
	)
	return err
}

const upsertTag = `-- name: UpsertTag :exec
INSERT INTO tags (name) VALUES($1) ON CONFLICT (name) DO NOTHING
`

func (q *Queries) UpsertTag(ctx context.Context, name pgtype.Text) error {
	_, err := q.db.Exec(ctx, upsertTag, name)
	return err
}
