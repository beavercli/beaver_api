// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLanguages = `-- name: CountLanguages :one
SELECT COUNT(*) FROM languages
`

func (q *Queries) CountLanguages(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLanguages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSnippetsFiltered = `-- name: CountSnippetsFiltered :one
SELECT COUNT(DISTINCT s.id) FROM snippets s
LEFT JOIN snippet_tags st ON s.id = st.snippet_id
WHERE ($1::BIGINT IS NULL OR s.language_id = $1::BIGINT)
  AND (COALESCE($2::BIGINT[], '{}') = '{}' OR st.tag_id = ANY($2::BIGINT[]))
`

type CountSnippetsFilteredParams struct {
	LanguageID pgtype.Int8
	TagIds     []int64
}

func (q *Queries) CountSnippetsFiltered(ctx context.Context, arg CountSnippetsFilteredParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSnippetsFiltered, arg.LanguageID, arg.TagIds)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTags = `-- name: CountTags :one
SELECT COUNT(*) FROM tags
`

func (q *Queries) CountTags(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTags)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteContributorsExcept = `-- name: DeleteContributorsExcept :exec
DELETE FROM contributors WHERE NOT (id = ANY($1::BIGINT[]))
`

func (q *Queries) DeleteContributorsExcept(ctx context.Context, ids []int64) error {
	_, err := q.db.Exec(ctx, deleteContributorsExcept, ids)
	return err
}

const deleteLanguagesExcept = `-- name: DeleteLanguagesExcept :exec
DELETE FROM languages WHERE NOT (id = ANY($1::BIGINT[]))
`

func (q *Queries) DeleteLanguagesExcept(ctx context.Context, ids []int64) error {
	_, err := q.db.Exec(ctx, deleteLanguagesExcept, ids)
	return err
}

const deleteSnippetsBefore = `-- name: DeleteSnippetsBefore :exec
DELETE FROM snippets WHERE created_at < $1
`

func (q *Queries) DeleteSnippetsBefore(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteSnippetsBefore, createdAt)
	return err
}

const deleteTagsExcept = `-- name: DeleteTagsExcept :exec
DELETE FROM tags WHERE NOT (id = ANY($1::BIGINT[]))
`

func (q *Queries) DeleteTagsExcept(ctx context.Context, ids []int64) error {
	_, err := q.db.Exec(ctx, deleteTagsExcept, ids)
	return err
}

const getContributorIDByEmail = `-- name: GetContributorIDByEmail :one
SELECT id FROM contributors WHERE email=$1
`

func (q *Queries) GetContributorIDByEmail(ctx context.Context, email pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getContributorIDByEmail, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getContributorsBySnippetID = `-- name: GetContributorsBySnippetID :many
SELECT c.id, c.first_name, c.last_name, c.email
FROM contributors c
INNER JOIN snippet_contributors sc ON c.id = sc.contributor_id
WHERE sc.snippet_id = $1
`

type GetContributorsBySnippetIDRow struct {
	ID        int64
	FirstName pgtype.Text
	LastName  pgtype.Text
	Email     pgtype.Text
}

func (q *Queries) GetContributorsBySnippetID(ctx context.Context, snippetID int64) ([]GetContributorsBySnippetIDRow, error) {
	rows, err := q.db.Query(ctx, getContributorsBySnippetID, snippetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContributorsBySnippetIDRow
	for rows.Next() {
		var i GetContributorsBySnippetIDRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLanguageBySnippetID = `-- name: GetLanguageBySnippetID :one
SELECT l.id, l.created_at, l.updated_at, l.name FROM languages l
INNER JOIN snippets s ON s.language_id = l.id
WHERE s.id = $1
`

func (q *Queries) GetLanguageBySnippetID(ctx context.Context, id int64) (Language, error) {
	row := q.db.QueryRow(ctx, getLanguageBySnippetID, id)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
	)
	return i, err
}

const getLanguageIDByName = `-- name: GetLanguageIDByName :one
SELECT id FROM languages WHERE name=$1
`

func (q *Queries) GetLanguageIDByName(ctx context.Context, name pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getLanguageIDByName, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getSnippetByID = `-- name: GetSnippetByID :one
SELECT
    s.id,
    s.title,
    s.code,
    s.project_url,
    s.created_at,
    s.updated_at,
    l.id AS language_id,
    l.name AS language_name
FROM snippets s
LEFT JOIN languages l ON s.language_id = l.id
WHERE s.id = $1
`

type GetSnippetByIDRow struct {
	ID           int64
	Title        pgtype.Text
	Code         pgtype.Text
	ProjectUrl   pgtype.Text
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	LanguageID   pgtype.Int8
	LanguageName pgtype.Text
}

func (q *Queries) GetSnippetByID(ctx context.Context, id int64) (GetSnippetByIDRow, error) {
	row := q.db.QueryRow(ctx, getSnippetByID, id)
	var i GetSnippetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Code,
		&i.ProjectUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LanguageID,
		&i.LanguageName,
	)
	return i, err
}

const getSnippetIDByTitle = `-- name: GetSnippetIDByTitle :one
SELECT id FROM snippets WHERE title=$1
`

func (q *Queries) GetSnippetIDByTitle(ctx context.Context, title pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getSnippetIDByTitle, title)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTagIDByName = `-- name: GetTagIDByName :one
SELECT id FROM tags WHERE name=$1
`

func (q *Queries) GetTagIDByName(ctx context.Context, name pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getTagIDByName, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTagsBySnippetID = `-- name: GetTagsBySnippetID :many
SELECT t.id, t.name
FROM tags t
INNER JOIN snippet_tags st ON t.id = st.tag_id
WHERE st.snippet_id = $1
`

type GetTagsBySnippetIDRow struct {
	ID   int64
	Name pgtype.Text
}

func (q *Queries) GetTagsBySnippetID(ctx context.Context, snippetID int64) ([]GetTagsBySnippetIDRow, error) {
	rows, err := q.db.Query(ctx, getTagsBySnippetID, snippetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsBySnippetIDRow
	for rows.Next() {
		var i GetTagsBySnippetIDRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsBySnippetIDs = `-- name: GetTagsBySnippetIDs :many
SELECT st.snippet_id, t.id, t.name
FROM tags t
INNER JOIN snippet_tags st ON t.id = st.tag_id
WHERE st.snippet_id = ANY($1::BIGINT[])
`

type GetTagsBySnippetIDsRow struct {
	SnippetID int64
	ID        int64
	Name      pgtype.Text
}

func (q *Queries) GetTagsBySnippetIDs(ctx context.Context, snippetIds []int64) ([]GetTagsBySnippetIDsRow, error) {
	rows, err := q.db.Query(ctx, getTagsBySnippetIDs, snippetIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsBySnippetIDsRow
	for rows.Next() {
		var i GetTagsBySnippetIDsRow
		if err := rows.Scan(&i.SnippetID, &i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserIDByEmail = `-- name: GetUserIDByEmail :one
SELECT id FROM users WHERE email = $1
`

func (q *Queries) GetUserIDByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDByEmail, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const linkSnippetContributor = `-- name: LinkSnippetContributor :exec
INSERT INTO snippet_contributors (snippet_id, contributor_id) VALUES($1, $2) ON CONFLICT (snippet_id, contributor_id) DO NOTHING
`

type LinkSnippetContributorParams struct {
	SnippetID     int64
	ContributorID int64
}

func (q *Queries) LinkSnippetContributor(ctx context.Context, arg LinkSnippetContributorParams) error {
	_, err := q.db.Exec(ctx, linkSnippetContributor, arg.SnippetID, arg.ContributorID)
	return err
}

const linkSnippetTag = `-- name: LinkSnippetTag :exec
INSERT INTO snippet_tags (snippet_id, tag_id) VALUES($1, $2) ON CONFLICT (snippet_id, tag_id) DO NOTHING
`

type LinkSnippetTagParams struct {
	SnippetID int64
	TagID     int64
}

func (q *Queries) LinkSnippetTag(ctx context.Context, arg LinkSnippetTagParams) error {
	_, err := q.db.Exec(ctx, linkSnippetTag, arg.SnippetID, arg.TagID)
	return err
}

const listAllContributors = `-- name: ListAllContributors :many
SELECT id, created_at, updated_at, first_name, last_name, email FROM contributors
`

func (q *Queries) ListAllContributors(ctx context.Context) ([]Contributor, error) {
	rows, err := q.db.Query(ctx, listAllContributors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contributor
	for rows.Next() {
		var i Contributor
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllLanguages = `-- name: ListAllLanguages :many
SELECT id, created_at, updated_at, name FROM languages
`

func (q *Queries) ListAllLanguages(ctx context.Context) ([]Language, error) {
	rows, err := q.db.Query(ctx, listAllLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTags = `-- name: ListAllTags :many
SELECT id, created_at, updated_at, name FROM tags
`

func (q *Queries) ListAllTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT id, created_at, updated_at, username, email, password_hash FROM users
`

func (q *Queries) ListAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContributors = `-- name: ListContributors :many

SELECT id, created_at, updated_at, first_name, last_name, email FROM contributors OFFSET $1 LIMIT $2
`

type ListContributorsParams struct {
	Offset int32
	Limit  int32
}

// Contributors
func (q *Queries) ListContributors(ctx context.Context, arg ListContributorsParams) ([]Contributor, error) {
	rows, err := q.db.Query(ctx, listContributors, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contributor
	for rows.Next() {
		var i Contributor
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLanguages = `-- name: ListLanguages :many

SELECT id, created_at, updated_at, name FROM languages OFFSET $1 LIMIT $2
`

type ListLanguagesParams struct {
	Offset int32
	Limit  int32
}

// Languages
func (q *Queries) ListLanguages(ctx context.Context, arg ListLanguagesParams) ([]Language, error) {
	rows, err := q.db.Query(ctx, listLanguages, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkedContributorIDs = `-- name: ListLinkedContributorIDs :many
SELECT DISTINCT(contributor_id) FROM snippet_contributors
`

func (q *Queries) ListLinkedContributorIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, listLinkedContributorIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var contributor_id int64
		if err := rows.Scan(&contributor_id); err != nil {
			return nil, err
		}
		items = append(items, contributor_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkedTagIDs = `-- name: ListLinkedTagIDs :many
SELECT DISTINCT(tag_id) FROM snippet_tags
`

func (q *Queries) ListLinkedTagIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, listLinkedTagIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var tag_id int64
		if err := rows.Scan(&tag_id); err != nil {
			return nil, err
		}
		items = append(items, tag_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSnippetIDs = `-- name: ListSnippetIDs :many
SELECT id FROM snippets
`

func (q *Queries) ListSnippetIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, listSnippetIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSnippetsFiltered = `-- name: ListSnippetsFiltered :many
SELECT DISTINCT
    s.id,
    s.title,
    s.project_url,
    l.id AS language_id,
    l.name AS language_name
FROM snippets s
LEFT JOIN languages l ON s.language_id = l.id
LEFT JOIN snippet_tags st ON s.id = st.snippet_id
WHERE ($1::BIGINT IS NULL OR s.language_id = $1::BIGINT)
  AND (COALESCE($2::BIGINT[], '{}') = '{}' OR st.tag_id = ANY($2::BIGINT[]))
ORDER BY s.id
OFFSET $3::INT LIMIT $4::INT
`

type ListSnippetsFilteredParams struct {
	LanguageID pgtype.Int8
	TagIds     []int64
	SqlOffset  int32
	SqlLimit   int32
}

type ListSnippetsFilteredRow struct {
	ID           int64
	Title        pgtype.Text
	ProjectUrl   pgtype.Text
	LanguageID   pgtype.Int8
	LanguageName pgtype.Text
}

func (q *Queries) ListSnippetsFiltered(ctx context.Context, arg ListSnippetsFilteredParams) ([]ListSnippetsFilteredRow, error) {
	rows, err := q.db.Query(ctx, listSnippetsFiltered,
		arg.LanguageID,
		arg.TagIds,
		arg.SqlOffset,
		arg.SqlLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSnippetsFilteredRow
	for rows.Next() {
		var i ListSnippetsFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ProjectUrl,
			&i.LanguageID,
			&i.LanguageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many

SELECT id, created_at, updated_at, name FROM tags OFFSET $1 LIMIT $2
`

type ListTagsParams struct {
	Offset int32
	Limit  int32
}

// Tags
func (q *Queries) ListTags(ctx context.Context, arg ListTagsParams) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listTags, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsedLanguageIDs = `-- name: ListUsedLanguageIDs :many
SELECT DISTINCT(language_id) FROM snippets
`

func (q *Queries) ListUsedLanguageIDs(ctx context.Context) ([]pgtype.Int8, error) {
	rows, err := q.db.Query(ctx, listUsedLanguageIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Int8
	for rows.Next() {
		var language_id pgtype.Int8
		if err := rows.Scan(&language_id); err != nil {
			return nil, err
		}
		items = append(items, language_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertContributor = `-- name: UpsertContributor :exec
INSERT INTO contributors (first_name, last_name, email) VALUES($1, $2, $3) ON CONFLICT (email) DO NOTHING
`

type UpsertContributorParams struct {
	FirstName pgtype.Text
	LastName  pgtype.Text
	Email     pgtype.Text
}

func (q *Queries) UpsertContributor(ctx context.Context, arg UpsertContributorParams) error {
	_, err := q.db.Exec(ctx, upsertContributor, arg.FirstName, arg.LastName, arg.Email)
	return err
}

const upsertLanguage = `-- name: UpsertLanguage :exec
INSERT INTO languages (name) VALUES($1) ON CONFLICT (name) DO NOTHING
`

func (q *Queries) UpsertLanguage(ctx context.Context, name pgtype.Text) error {
	_, err := q.db.Exec(ctx, upsertLanguage, name)
	return err
}

const upsertSnippet = `-- name: UpsertSnippet :one

INSERT INTO snippets (title, code, project_url, language_id, user_id, created_at)
VALUES($1, $2, $3, $4, $5, $6)
ON CONFLICT (title) DO UPDATE SET created_at = EXCLUDED.created_at
RETURNING id
`

type UpsertSnippetParams struct {
	Title      pgtype.Text
	Code       pgtype.Text
	ProjectUrl pgtype.Text
	LanguageID pgtype.Int8
	UserID     pgtype.Int8
	CreatedAt  pgtype.Timestamptz
}

// Snippets
func (q *Queries) UpsertSnippet(ctx context.Context, arg UpsertSnippetParams) (int64, error) {
	row := q.db.QueryRow(ctx, upsertSnippet,
		arg.Title,
		arg.Code,
		arg.ProjectUrl,
		arg.LanguageID,
		arg.UserID,
		arg.CreatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertTag = `-- name: UpsertTag :exec
INSERT INTO tags (name) VALUES($1) ON CONFLICT (name) DO NOTHING
`

func (q *Queries) UpsertTag(ctx context.Context, name pgtype.Text) error {
	_, err := q.db.Exec(ctx, upsertTag, name)
	return err
}

const upsertUser = `-- name: UpsertUser :exec

INSERT INTO users (username, email, password_hash)
VALUES ($1, $2, $3)
ON CONFLICT (email) DO NOTHING
`

type UpsertUserParams struct {
	Username     string
	Email        string
	PasswordHash string
}

// Users
func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.db.Exec(ctx, upsertUser, arg.Username, arg.Email, arg.PasswordHash)
	return err
}
